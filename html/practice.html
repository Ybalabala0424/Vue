<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" type="text/css" href="../css/practice.css">
    <script src="https://unpkg.com/vue"></script>
</head>
<body>
    <div id="app">
        <div class="load">
            <h2><p>安装</p></h2>
            <h3><p>1. 直接用<\script>引用<br></p></h3>
            <h4><p>直接下载并用<\script>标签引入，Vue会被注册为一个全局变量
            </p></h4>
            <h3><p>2. CDN</p></h3>
            <h4><p>链接到一个可以手动更新的指定版本号<br>
                src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js<br>
                可以在上述网址上浏览NPM包的源代码<br>
                把vue.js换乘vue.min.js可以带来比开发环境下更快的速度体验<br>
            </p></h4>
            <h3><p>3. NPM<br></p></h3>
            <h4><p>使用NPM安装<br>
                $ npm install vue<br>
            </p></h4>
            <hr/>
        </div>

        <div class="introduce">
            <h2><p>介绍<br></p></h2>
            <h4><p>  是一套用于构建用户界面的渐进式框架，可以自底向上逐层应用，核心库只关注图层，能够为复杂的单页应用提供驱动</p></h4>

            <div class="exam">
                <h4><p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统</p></h4>
                {{ message }}
            </div>
            <br>

            <div class="exam">
                <span v-bind:title="message1">
                v-bind特性称为指令，会在渲染的DOM上应用特殊的响应式行为<br>
                鼠标悬停几秒钟查看此处动态绑定的提示信息！
                </span>
            </div>

            <div class="exam">
                <h4><p>v-if控制切换一个元素</p></h4>
                <p v-if="seen">现在你看到我了</p>
            </div>

            <div class="exam">
                <h4><p>为了让用户和你的应用进行交互，我们可以用 v-on 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法</p></h4>
                <p>{{ message2 }}</p>
                <button v-on:click="reverseMessage">逆转消息</button>
            </div>

            <div class="exam">
                <h4><p>Vue 还提供了 v-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定。</p></h4>
                <p>{{ message3}}</p>
                <input v-model="message3">
            </div>

            <h4><P>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用<br>
                在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例<br>
                子单元通过 prop 接口与父单元进行了良好的解耦<br>
            </P></h4>
            <div class="exam">
                <ol>
                    <todo-item
                            v-for="item in groceryList"
                            v-bind:todo="item"
                            v-bind:key="item.id">
                    </todo-item>
                </ol>
            </div>

            <hr>
        </div>

        <div class="vueex">
            <h2><p>Vue实例<br></p></h2>

            <div class="exam">
                <p>{{ oof }}</p>
                <button v-on:click="oof = '不是汕大课程表'"><p>改变一下</p></button>
                <!-- 这里的 `foo` 不会更新！ -->
                <p>这个值属性设为freeze</p>
                <p>把属性设为freeze后将不会改变</p>
            </div>

            <hr>
        </div>

        <div class="grammer">
            <h2><p>模板语法<br></p></h2>

            <div class="exam">
                <p>用原来的代码块: {{ rawHtml }}</p>
                <p>用v-html来表示: <span v-html="rawHtml"></span></p>
                <p>v-html直接讲代码块内的语句进行编译</p>
            </div>

            <div class="exam">
                <p>v-once只能执行一次性地插值，当数据改变时，插值处的内容不会更新</p>
                <span v-once>这个将不会改变: {{ msg }}</span>
            </div>

        </div>

        <div class="compute">
            <h2><p>计算属性和侦听器<br></p></h2>

            <div class="exam">
                <p>原始句子: "{{ message3 }}"</p>
                <p>调用reverseMessage方法后转化的句子:"{{ reversedMessage() }}"</p>
            </div>

            <div class="exam">
                <p>当需要在数据变化时执行异步或开销较大的操作时,vue通过js中的watch操作允许我们执行异步操作，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。</p>
                <p>下面是文档内的例子</p>
                <p>
                    Ask a yes/no question:
                    <input v-model="question">
                </p>
                <p>{{ answer }}</p>
            </div>

            <hr>
        </div>

        <div class="an">
            <h2><p>Class与Style绑定<br></p></h2>

            <div class="exam">
                <p  v-bind:class="isActive">传给 v-bind:class 一个对象，以动态地切换 class</p>
                <p  v-bind:style="myStyle">用v-bind:style直接绑定到一个内联样式对象</p>
                <button v-on:click="Change">变换外联文本颜色</button>
            </div>

            <hr>
        </div>

        <div class="tiaojian">

            <h2><p>条件渲染<br></p></h2>
            <div class="exam">
                <template v-if="key">
                    <p>因为 v-if 是一个指令，所以必须将它添加到一个元素上。</p>
                    <p>v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。</p>
                </template>
                <template v-if="key">
                    <label>key管理可复用的元素1</label>
                </template>
                <template v-else>
                    <label>元素2</label>
                </template>
                <button v-on:click="ch">查看另一元素</button>
            </div>

            <hr>
        </div>

        <div class="list">
            <h2><p>列表渲染<br></p></h2>

            <div class="exam">
                <ul id="v-for-object" class="demo">
                    <li v-for="value in object">
                        {{ value }}
                    </li>
                    <div v-for="(value, key, index) in object">
                        {{ index }}. {{ key }}: {{ value }}
                    </div>
                </ul>
            </div>

        </div>

        <div class="deal">
            <h2><p>事件处理<br></p></h2>
            <div class="exam">
                <button v-on:click="say('hi')">Say hi</button>
                <button v-on:click="say('what')">Say what</button>
            </div>

            <div class="exam">
                <p>这个月没写日报的次数：{{ counter }}</p>
                <button v-on:click="counter += 1">增加一次</button>
            </div>
        </div>

        <div id="forminput">
            <h2><p>表单输入绑定<br></p></h2>
            <div class="exam">
                <input v-model="message4" placeholder="edit me">
                <p>信息是: {{ message4 }}</p>
            </div>

            <div class="exam">
                <p>可以显示多行信息</p>
                <textarea v-model="message5" placeholder="add multiple lines"></textarea><br>
                <span>多行信息内容:</span>
                <p style="white-space: pre-line;">{{ message5 }}</p>
                <br>
            </div>

        </div>

    </div>
    <script src="https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"></script>
<script>
    Vue.component('todo-item', {
        props: ['todo'],
        template: '<li>{{ todo.text }}</li>'
    })
    var app = new Vue({
        el:'#app',
        data:{
            message:'Hello Vue',
            message1:'页面加载于 ' + new Date().toLocaleString(),
            message2:'Hello World',
            message3:'今天你吃饭了吗？',
            message4:'',
            message5:'',
            seen:true,
            groceryList: [
                { id: 0, text: '微积分' },
                { id: 1, text: '英语' },
                { id: 2, text:'电工电子学' },
                { id: 3, text:'爵士鼓' }
            ],
            oof:'汕大课程表',
            rawHtml: '<span style="color:red">This should be red.</span>',
            msg:"123",
            isActive:{
                'active':true
            },
            myStyle:{
                fontSize:'1rem',
                backgroundColor:'yellow'
            },
            question: '',
            answer: 'I cannot give you an answer until you ask a question!',
            key:true,
            object: {
                姓: '小',
                名: '仙女',
                生日: '06/01'
            },
            counter: 0,
        },
        watch: {
            // 如果 `question` 发生改变，这个函数就会运行
            question: function (newQuestion, oldQuestion) {
                this.answer = 'Waiting for you to stop typing...'
                this.debouncedGetAnswer()
            }
        },
        created: function () {
            // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。
            // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率
            // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于
            // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，
            // 请参考：https://lodash.com/docs#debounce
            this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)
        },
        methods:{
            reverseMessage: function () {
                this.message2 = this.message2.split('').reverse().join('')
            },
            reversedMessage: function () {
                return this.message3.split('').reverse().join('')
            },
            Change:function(){
                this.myStyle.backgroundColor = 'red'
            },
            getAnswer: function () {
                if (this.question.indexOf('?') === -1) {
                    this.answer = 'Questions usually contain a question mark. ;-)'
                    return
                }
                this.answer = 'Thinking...'
                var vm = this
                axios.get('https://yesno.wtf/api')
                    .then(function (response) {
                        vm.answer = _.capitalize(response.data.answer)
                    })
                    .catch(function (error) {
                        vm.answer = 'Error! Could not reach the API. ' + error
                    })
            },
            ch:function(){
                this.key = !this.key
            },
            say: function (message) {
                alert(message)
            }
        }
    })
</script>
</body>
</html>